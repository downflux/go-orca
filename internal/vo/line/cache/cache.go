package cache

import (
	"fmt"

	"github.com/downflux/go-geometry/2d/hyperplane"
	"github.com/downflux/go-geometry/2d/hypersphere"
	"github.com/downflux/go-geometry/2d/line"
	"github.com/downflux/go-geometry/2d/segment"
	"github.com/downflux/go-geometry/2d/vector"
	"github.com/downflux/go-orca/agent"
	"github.com/downflux/go-orca/internal/geometry/cone"
	"github.com/downflux/go-orca/internal/vo/line/cache/domain"

	voagent "github.com/downflux/go-orca/internal/vo/agent"
	mock "github.com/downflux/go-orca/internal/vo/line/agent"
)

type C struct {
	// segment represents the physical line segment of the obstacle.
	segment segment.S

	// velocity is the absolute obstacle velocity.
	velocity vector.V

	agent agent.A
	tau   float64
}

func New(s segment.S, v vector.V, a agent.A, tau float64) *C {
	return &C{
		segment:  s,
		velocity: v,
		agent:    a,
		tau:      tau,
	}
}

// domain returns the domain in p-space of interaction between the velocity
// obstacle and
// the agent positions. Here, "left" refers the the end of the characteristic line segment
// which has a minimal parametric t value, and "right" refers to the opposite
// end. Note that this convention does not take into account the relative
// orientation of agent itself.
func (c C) domain() domain.D {
	// t is the projected parametric value along the extended line. We need
	// to detect the case where t extends beyond the segment itself, and
	// seg.T() truncates at the segment endpoints.
	t := c.segment.L().T(c.agent.P())

	// Agent physically collides with the semicircle on the left side of the line
	// segment.
	if t <= c.segment.TMin() && vector.Magnitude(
		c.P(c.segment.TMin()),
	) <= c.agent.R() {
		return domain.CollisionLeft
	}

	// Agent physically collides with the semicircle on the right side of the line
	// segment.
	if t >= c.segment.TMax() && vector.Magnitude(
		c.P(c.segment.TMax()),
	) <= c.agent.R() {
		return domain.CollisionRight
	}

	// d is perpendicular distance between the agent and the line.
	d := c.segment.L().Distance(c.agent.P())

	// Agent physically collides wth the line segment itself.
	if (c.segment.TMin() <= t && t <= c.segment.TMax()) && d <= c.agent.R() {
		return domain.CollisionLine
	}

	return domain.Normal
}

// l calculates the left vector of the tangent line from the agent position to
// the base of the truncated line segment.
//
// N.B.: â„“ may be generated by either the left or right truncation circle, but
// is always the left-side tangent line of that circle. The right truncation
// circle will be used if the it obstructs the view of the left truncation
// circle (the oblique case), or if the agent is "flipped" across the truncation
// line.
func (c C) l() vector.V {
	t := c.segment.L().T(c.agent.P())
	d := c.segment.L().Distance(c.agent.P())

	p := c.segment.L().L(c.segment.TMin())

	if (
	// The right truncation circle is obstructing the view of the
	// left end of the line segment. Use the right circle to
	// calculate the left tangent leg.
	t >= c.segment.TMax() && d <= c.agent.R()) || (
	// The agent is flipped across the truncation line.
	vector.Determinant(
		c.segment.L().D(),
		vector.Sub(
			c.segment.L().L(c.segment.TMin()),
			c.agent.P()),
	) < 0) {
		p = c.segment.L().L(c.segment.TMax())
	}

	cn, err := cone.New(
		*hypersphere.New(vector.Sub(p, c.agent.P()), c.agent.R()/c.tau),
	)

	if err != nil {
		panic(fmt.Sprintf("cannot construct left tangent leg: %v", err))
	}
	return cn.L()
}

// r calculates the right vector of the tangent line from the agent position to
// the base of the truncated line segment.
func (c C) r() vector.V {
	t := c.segment.L().T(c.agent.P())
	d := c.segment.L().Distance(c.agent.P())

	p := c.segment.L().L(c.segment.TMax())

	if (
	// The left truncation circle is obstructing the view of the
	// right end of the line segment. Use the left circle to
	// calculate the right tangent leg.
	t <= c.segment.TMin() && d <= c.agent.R()) || (
	// The agent is flipped across the truncation line.
	vector.Determinant(
		c.segment.L().D(),
		vector.Sub(
			c.segment.L().L(c.segment.TMin()),
			c.agent.P()),
	) < 0) {
		p = c.segment.L().L(c.segment.TMin())
	}

	cn, err := cone.New(
		*hypersphere.New(vector.Sub(p, c.agent.P()), c.agent.R()/c.tau),
	)

	if err != nil {
		panic(fmt.Sprintf("cannot construct right tangent leg: %v", err))
	}
	return cn.R()
}

func (c C) ORCA() hyperplane.HP {
	lvo := voagent.New(
		*mock.New(
			c.segment.L().L(c.segment.TMin()),
			c.velocity,
		),
	)
	rvo := voagent.New(
		*mock.New(
			c.segment.L().L(c.segment.TMax()),
			c.velocity,
		),
	)

	switch c.domain() {
	case domain.CollisionLeft:
		return lvo.ORCA(c.agent, c.tau)
	case domain.CollisionRight:
		return rvo.ORCA(c.agent, c.tau)
	case domain.CollisionLine:
		return *hyperplane.New(
			c.S().L().P(),
			*vector.New(
				c.S().L().N().Y(),
				-c.S().L().N().X(),
			),
		)
	}
	panic("unimplemented case")
}

// S returns the characteristic line segment defining the velocity obstacle,
// taking into account the time scalar ðœ.
func (c C) S() segment.S { return s(c.segment, c.agent, c.tau) }

func (c C) V() vector.V { return v(c.velocity, c.agent) }

// P returns the position vector in p-space from the agent to a specific point
// along the velocity obstacle line. Note that the distance here is independent
// of the time scaling factor ðœ.
func (c C) P(t float64) vector.V { return p(c.segment, c.agent, t) }

// w returns the perpendicular vector from the line to the relative velocity v.
func (c C) w() vector.V {
	p, ok := c.S().L().Intersect(*line.New(*vector.New(0, 0), c.V()))
	if !ok {
		// TODO(minkezhang): Implement normal line.
		return *vector.New(0, 0)
	}
	return vector.Sub(c.V(), c.S().L().L(c.S().T(p)))
}

// P calculates the relative physical position from the line obstacle to the
// agent position.
//
// The input parameter t is the parametric value along the line segment.
//
// The returned relative position vector points away from the line segment.
//
// N.B.: The position does not scale with the time factor ðœ.
func p(s segment.S, a agent.A, t float64) vector.V {
	return vector.Sub(s.L().L(t), a.P())
}

// v returns the relative velocity between the agent and the obstacle line.
func v(v vector.V, a agent.A) vector.V { return vector.Sub(a.V(), v) }

// s generates a scaled line segment based on the lookahead time and the agent.
func s(s segment.S, a agent.A, tau float64) segment.S {
	return *segment.New(
		*line.New(
			vector.Scale(1/tau, vector.Sub(s.L().P(), a.P())),
			vector.Scale(1/tau, s.L().D()),
		),
		s.TMin(),
		s.TMax(),
	)
}
